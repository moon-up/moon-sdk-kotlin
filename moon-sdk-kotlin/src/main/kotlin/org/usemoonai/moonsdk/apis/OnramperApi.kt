/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.usemoonai.moonsdk.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.usemoonai.moonsdk.models.GetSupportedOnRampsResponse
import org.usemoonai.moonsdk.models.Quote
import org.usemoonai.moonsdk.models.SellQuote
import org.usemoonai.moonsdk.models.SupportedAssetResponse
import org.usemoonai.moonsdk.models.SupportedCurrenciesResponse
import org.usemoonai.moonsdk.models.SupportedDefaultResponse
import org.usemoonai.moonsdk.models.SupportedPaymentTypesCurrencyResponse
import org.usemoonai.moonsdk.models.TransactionInput

import com.squareup.moshi.Json

import org.usemoonai.moonsdk.infrastructure.ApiClient
import org.usemoonai.moonsdk.infrastructure.ApiResponse
import org.usemoonai.moonsdk.infrastructure.ClientException
import org.usemoonai.moonsdk.infrastructure.ClientError
import org.usemoonai.moonsdk.infrastructure.ServerException
import org.usemoonai.moonsdk.infrastructure.ServerError
import org.usemoonai.moonsdk.infrastructure.MultiValueMap
import org.usemoonai.moonsdk.infrastructure.PartConfig
import org.usemoonai.moonsdk.infrastructure.RequestConfig
import org.usemoonai.moonsdk.infrastructure.RequestMethod
import org.usemoonai.moonsdk.infrastructure.ResponseType
import org.usemoonai.moonsdk.infrastructure.Success
import org.usemoonai.moonsdk.infrastructure.toMultiValue

class OnramperApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://beta.usemoon.ai")
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param accountName 
     * @param transactionInput 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperCheckout(authorization: kotlin.String, accountName: kotlin.String, transactionInput: TransactionInput) : kotlin.Any {
        val localVarResponse = onRamperCheckoutWithHttpInfo(authorization = authorization, accountName = accountName, transactionInput = transactionInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param accountName 
     * @param transactionInput 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperCheckoutWithHttpInfo(authorization: kotlin.String, accountName: kotlin.String, transactionInput: TransactionInput) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = onRamperCheckoutRequestConfig(authorization = authorization, accountName = accountName, transactionInput = transactionInput)

        return request<TransactionInput, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperCheckout
     *
     * @param authorization 
     * @param accountName 
     * @param transactionInput 
     * @return RequestConfig
     */
    fun onRamperCheckoutRequestConfig(authorization: kotlin.String, accountName: kotlin.String, transactionInput: TransactionInput) : RequestConfig<TransactionInput> {
        val localVariableBody = transactionInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/onramper/fund/${accountName}".replace("{"+"accountName"+"}", encodeURIComponent(accountName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @param fiat 
     * @param crypto 
     * @param amount 
     * @param paymentMethod  (optional, default to "creditcard")
     * @param uuid  (optional, default to "")
     * @param clientName  (optional, default to "")
     * @param country  (optional, default to "")
     * @return kotlin.collections.List<Quote>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperGetQuotesBuy(authorization: kotlin.String, fiat: kotlin.String, crypto: kotlin.String, amount: kotlin.Double, paymentMethod: kotlin.String? = "creditcard", uuid: kotlin.String? = "", clientName: kotlin.String? = "", country: kotlin.String? = "") : kotlin.collections.List<Quote> {
        val localVarResponse = onRamperGetQuotesBuyWithHttpInfo(authorization = authorization, fiat = fiat, crypto = crypto, amount = amount, paymentMethod = paymentMethod, uuid = uuid, clientName = clientName, country = country)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Quote>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param fiat 
     * @param crypto 
     * @param amount 
     * @param paymentMethod  (optional, default to "creditcard")
     * @param uuid  (optional, default to "")
     * @param clientName  (optional, default to "")
     * @param country  (optional, default to "")
     * @return ApiResponse<kotlin.collections.List<Quote>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperGetQuotesBuyWithHttpInfo(authorization: kotlin.String, fiat: kotlin.String, crypto: kotlin.String, amount: kotlin.Double, paymentMethod: kotlin.String?, uuid: kotlin.String?, clientName: kotlin.String?, country: kotlin.String?) : ApiResponse<kotlin.collections.List<Quote>?> {
        val localVariableConfig = onRamperGetQuotesBuyRequestConfig(authorization = authorization, fiat = fiat, crypto = crypto, amount = amount, paymentMethod = paymentMethod, uuid = uuid, clientName = clientName, country = country)

        return request<Unit, kotlin.collections.List<Quote>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperGetQuotesBuy
     *
     * @param authorization 
     * @param fiat 
     * @param crypto 
     * @param amount 
     * @param paymentMethod  (optional, default to "creditcard")
     * @param uuid  (optional, default to "")
     * @param clientName  (optional, default to "")
     * @param country  (optional, default to "")
     * @return RequestConfig
     */
    fun onRamperGetQuotesBuyRequestConfig(authorization: kotlin.String, fiat: kotlin.String, crypto: kotlin.String, amount: kotlin.Double, paymentMethod: kotlin.String?, uuid: kotlin.String?, clientName: kotlin.String?, country: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("fiat", listOf(fiat.toString()))
                put("crypto", listOf(crypto.toString()))
                put("amount", listOf(amount.toString()))
                if (paymentMethod != null) {
                    put("paymentMethod", listOf(paymentMethod.toString()))
                }
                if (uuid != null) {
                    put("uuid", listOf(uuid.toString()))
                }
                if (clientName != null) {
                    put("clientName", listOf(clientName.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/onramper/quotes/buy",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @param fiat 
     * @param crypto 
     * @param amount 
     * @param paymentMethod  (optional, default to "creditcard")
     * @param uuid  (optional, default to "")
     * @param clientName  (optional, default to "")
     * @param country  (optional, default to "")
     * @return kotlin.collections.List<SellQuote>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperGetQuotesSell(authorization: kotlin.String, fiat: kotlin.String, crypto: kotlin.String, amount: kotlin.Double, paymentMethod: kotlin.String? = "creditcard", uuid: kotlin.String? = "", clientName: kotlin.String? = "", country: kotlin.String? = "") : kotlin.collections.List<SellQuote> {
        val localVarResponse = onRamperGetQuotesSellWithHttpInfo(authorization = authorization, fiat = fiat, crypto = crypto, amount = amount, paymentMethod = paymentMethod, uuid = uuid, clientName = clientName, country = country)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SellQuote>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param fiat 
     * @param crypto 
     * @param amount 
     * @param paymentMethod  (optional, default to "creditcard")
     * @param uuid  (optional, default to "")
     * @param clientName  (optional, default to "")
     * @param country  (optional, default to "")
     * @return ApiResponse<kotlin.collections.List<SellQuote>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperGetQuotesSellWithHttpInfo(authorization: kotlin.String, fiat: kotlin.String, crypto: kotlin.String, amount: kotlin.Double, paymentMethod: kotlin.String?, uuid: kotlin.String?, clientName: kotlin.String?, country: kotlin.String?) : ApiResponse<kotlin.collections.List<SellQuote>?> {
        val localVariableConfig = onRamperGetQuotesSellRequestConfig(authorization = authorization, fiat = fiat, crypto = crypto, amount = amount, paymentMethod = paymentMethod, uuid = uuid, clientName = clientName, country = country)

        return request<Unit, kotlin.collections.List<SellQuote>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperGetQuotesSell
     *
     * @param authorization 
     * @param fiat 
     * @param crypto 
     * @param amount 
     * @param paymentMethod  (optional, default to "creditcard")
     * @param uuid  (optional, default to "")
     * @param clientName  (optional, default to "")
     * @param country  (optional, default to "")
     * @return RequestConfig
     */
    fun onRamperGetQuotesSellRequestConfig(authorization: kotlin.String, fiat: kotlin.String, crypto: kotlin.String, amount: kotlin.Double, paymentMethod: kotlin.String?, uuid: kotlin.String?, clientName: kotlin.String?, country: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("fiat", listOf(fiat.toString()))
                put("crypto", listOf(crypto.toString()))
                put("amount", listOf(amount.toString()))
                if (paymentMethod != null) {
                    put("paymentMethod", listOf(paymentMethod.toString()))
                }
                if (uuid != null) {
                    put("uuid", listOf(uuid.toString()))
                }
                if (clientName != null) {
                    put("clientName", listOf(clientName.toString()))
                }
                if (country != null) {
                    put("country", listOf(country.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/onramper/quotes/sell",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @param source 
     * @param country 
     * @return SupportedAssetResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperGetSupportedAssets(authorization: kotlin.String, source: kotlin.String, country: kotlin.String) : SupportedAssetResponse {
        val localVarResponse = onRamperGetSupportedAssetsWithHttpInfo(authorization = authorization, source = source, country = country)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupportedAssetResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param source 
     * @param country 
     * @return ApiResponse<SupportedAssetResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperGetSupportedAssetsWithHttpInfo(authorization: kotlin.String, source: kotlin.String, country: kotlin.String) : ApiResponse<SupportedAssetResponse?> {
        val localVariableConfig = onRamperGetSupportedAssetsRequestConfig(authorization = authorization, source = source, country = country)

        return request<Unit, SupportedAssetResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperGetSupportedAssets
     *
     * @param authorization 
     * @param source 
     * @param country 
     * @return RequestConfig
     */
    fun onRamperGetSupportedAssetsRequestConfig(authorization: kotlin.String, source: kotlin.String, country: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("source", listOf(source.toString()))
                put("country", listOf(country.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/onramper/assets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @param type 
     * @return SupportedCurrenciesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperGetSupportedCurrencies(authorization: kotlin.String, type: kotlin.String) : SupportedCurrenciesResponse {
        val localVarResponse = onRamperGetSupportedCurrenciesWithHttpInfo(authorization = authorization, type = type)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupportedCurrenciesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param type 
     * @return ApiResponse<SupportedCurrenciesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperGetSupportedCurrenciesWithHttpInfo(authorization: kotlin.String, type: kotlin.String) : ApiResponse<SupportedCurrenciesResponse?> {
        val localVariableConfig = onRamperGetSupportedCurrenciesRequestConfig(authorization = authorization, type = type)

        return request<Unit, SupportedCurrenciesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperGetSupportedCurrencies
     *
     * @param authorization 
     * @param type 
     * @return RequestConfig
     */
    fun onRamperGetSupportedCurrenciesRequestConfig(authorization: kotlin.String, type: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("type", listOf(type.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/onramper/currencies",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @param country 
     * @param type 
     * @return SupportedDefaultResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperGetSupportedDefaultsAll(authorization: kotlin.String, country: kotlin.String, type: kotlin.String) : SupportedDefaultResponse {
        val localVarResponse = onRamperGetSupportedDefaultsAllWithHttpInfo(authorization = authorization, country = country, type = type)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupportedDefaultResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param country 
     * @param type 
     * @return ApiResponse<SupportedDefaultResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperGetSupportedDefaultsAllWithHttpInfo(authorization: kotlin.String, country: kotlin.String, type: kotlin.String) : ApiResponse<SupportedDefaultResponse?> {
        val localVariableConfig = onRamperGetSupportedDefaultsAllRequestConfig(authorization = authorization, country = country, type = type)

        return request<Unit, SupportedDefaultResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperGetSupportedDefaultsAll
     *
     * @param authorization 
     * @param country 
     * @param type 
     * @return RequestConfig
     */
    fun onRamperGetSupportedDefaultsAllRequestConfig(authorization: kotlin.String, country: kotlin.String, type: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("country", listOf(country.toString()))
                put("type", listOf(type.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/onramper/defaults",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @return GetSupportedOnRampsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperGetSupportedOnRampsAll(authorization: kotlin.String) : GetSupportedOnRampsResponse {
        val localVarResponse = onRamperGetSupportedOnRampsAllWithHttpInfo(authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSupportedOnRampsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @return ApiResponse<GetSupportedOnRampsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperGetSupportedOnRampsAllWithHttpInfo(authorization: kotlin.String) : ApiResponse<GetSupportedOnRampsResponse?> {
        val localVariableConfig = onRamperGetSupportedOnRampsAllRequestConfig(authorization = authorization)

        return request<Unit, GetSupportedOnRampsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperGetSupportedOnRampsAll
     *
     * @param authorization 
     * @return RequestConfig
     */
    fun onRamperGetSupportedOnRampsAllRequestConfig(authorization: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/onramper/onramps",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @param fiat 
     * @param country 
     * @param type 
     * @return SupportedPaymentTypesCurrencyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperGetSupportedPaymentTypes(authorization: kotlin.String, fiat: kotlin.String, country: kotlin.String, type: kotlin.String) : SupportedPaymentTypesCurrencyResponse {
        val localVarResponse = onRamperGetSupportedPaymentTypesWithHttpInfo(authorization = authorization, fiat = fiat, country = country, type = type)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupportedPaymentTypesCurrencyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param fiat 
     * @param country 
     * @param type 
     * @return ApiResponse<SupportedPaymentTypesCurrencyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperGetSupportedPaymentTypesWithHttpInfo(authorization: kotlin.String, fiat: kotlin.String, country: kotlin.String, type: kotlin.String) : ApiResponse<SupportedPaymentTypesCurrencyResponse?> {
        val localVariableConfig = onRamperGetSupportedPaymentTypesRequestConfig(authorization = authorization, fiat = fiat, country = country, type = type)

        return request<Unit, SupportedPaymentTypesCurrencyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperGetSupportedPaymentTypes
     *
     * @param authorization 
     * @param fiat 
     * @param country 
     * @param type 
     * @return RequestConfig
     */
    fun onRamperGetSupportedPaymentTypesRequestConfig(authorization: kotlin.String, fiat: kotlin.String, country: kotlin.String, type: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("fiat", listOf(fiat.toString()))
                put("country", listOf(country.toString()))
                put("type", listOf(type.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/onramper/payment-types",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @param fiat 
     * @param country 
     * @return SupportedPaymentTypesCurrencyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun onRamperGetSupportedPaymentTypesFiat(authorization: kotlin.String, fiat: kotlin.String, country: kotlin.String) : SupportedPaymentTypesCurrencyResponse {
        val localVarResponse = onRamperGetSupportedPaymentTypesFiatWithHttpInfo(authorization = authorization, fiat = fiat, country = country)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SupportedPaymentTypesCurrencyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param fiat 
     * @param country 
     * @return ApiResponse<SupportedPaymentTypesCurrencyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun onRamperGetSupportedPaymentTypesFiatWithHttpInfo(authorization: kotlin.String, fiat: kotlin.String, country: kotlin.String) : ApiResponse<SupportedPaymentTypesCurrencyResponse?> {
        val localVariableConfig = onRamperGetSupportedPaymentTypesFiatRequestConfig(authorization = authorization, fiat = fiat, country = country)

        return request<Unit, SupportedPaymentTypesCurrencyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation onRamperGetSupportedPaymentTypesFiat
     *
     * @param authorization 
     * @param fiat 
     * @param country 
     * @return RequestConfig
     */
    fun onRamperGetSupportedPaymentTypesFiatRequestConfig(authorization: kotlin.String, fiat: kotlin.String, country: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("fiat", listOf(fiat.toString()))
                put("country", listOf(country.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["Authorization"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/onramper/payment-types/fiat",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
